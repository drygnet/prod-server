import { Request, Response } from 'express';
import express from 'express';
import jwt from 'express-jwt';
import IAppLocals from './models/IAppLocals';
import config from './server/db';
import { initDB } from './server/initDB';
import {
  addMetadata,
  appIndex,
  errorHandler,
  handleFunction,
  resolveApp,
  resolveCollection,
  resolveDb,
  setClient
} from './server/middleware';
import { MongoHelper } from './server/mongo.helper';
import { publicKey } from './server/public.key';
import validateShema from './server/validate';

MongoHelper.connect(config.DBServer).then((res) => {
  const client = res;
  setClient(client);
  initDB(client);
});

const srv = express();
const port = 4000;

srv.use(express.json());
srv.use(jwt({ secret: publicKey, resultProperty: 'locals.user' }));
srv.use(addMetadata);
srv.use('/appIndex', appIndex);
srv.use('/:appName/*', resolveApp);
srv.use('/:appName/files', resolveDb);
srv.use('/:appName/functions/:functionName', [handleFunction]);
srv.use('/:appName/db/:collection/:id*?', [resolveDb, resolveCollection]);

srv.get('/:appName/info/:collection', resolveDb, async (req, res) => {
  const { db } = (res.locals as IAppLocals);
  const collinfo: any = await db.listCollections({ name: req.params.collection }).next();
  const info = collinfo.options;
  res.send(info);
});

// Add item to array in document (:id)
srv.post('/:appName/db/:collection/:id/:array', (req: Request, res: Response) => {
  const { collection, client, id, metadata } = (res.locals as IAppLocals);
  const arrayName = req.params.array;
  collection.findOneAndUpdate(
    { _id: id },
    {
      $push: { [arrayName]: req.body },
      $set: { _modified: metadata }
    },
    { returnOriginal: false })
    .then((document: any) => {
      res.send(document.value);
    })
    .catch((error: any) => {
      validateShema(client, req, res, error);
    });
});

// delete item from array in document (:id) matching body (yes send a body with delete)
srv.delete('/:appName/db/:collection/:id/:array', (req: Request, res: Response) => {
  const { collection, client, id, metadata } = (res.locals as IAppLocals);
  const arrayName = req.params.array;
  collection.findOneAndUpdate(
    { _id: id },
    {
      $pull: { [arrayName]: req.body },
      $set: { _modified: metadata }
    },
    { returnOriginal: false })
    .then((document: any) => {
      res.send(document.value);
    })
    .catch((error: any) => {
      res.status(400);
      res.send(error);
    });
});

// Actions with ID (GET (by ID), PUT and DELETE)
srv.use('/:appName/db/:collection/:id', async (req: Request, res: Response) => {
  const { client, id, collection, metadata } = (res.locals as IAppLocals);
  let doc: any;
  if (req.body) {
    // id and metadata generated by server or database, user should not post
    delete req.body._id;
    delete req.body._modified;
    delete req.body._created;
  }
  switch (req.method) {

    case 'GET':
      doc = await collection.findOne({ _id: id });
      res.send(doc);
      break;

    case 'PUT':
      req.body._modified = metadata;
      collection.findOneAndUpdate({ _id: id }, { $set: req.body }, { returnOriginal: false })
        .then((document: any) => {
          res.send(document.value);
        })
        .catch((error: any) => {
          // not true, but skips one validation error
          req.body._created = metadata;
          validateShema(client, req, res, error);
        });
      break;

    case 'DELETE':
      collection.deleteOne({ _id: id })
        .then((result: any) => {
          res.send(result);
        })
        .catch((error: any) => {
          res.status(400);
          res.send(error);
        });
      break;

    default:
      res.status(400);
      res.send({ message: `${req.method} not available (with ID in URL)` });
  }

});

// Actions without ID (POST and GET)
srv.use('/:appName/db/:collection', async (req: Request, res: Response) => {
  const { client, id, collection, metadata } = (res.locals as IAppLocals);
  let doc: any;
  if (req.body) {
    // id and metadata generated by server or database, user should not post
    delete req.body._id;
    delete req.body._modified;
    delete req.body._created;
  }
  switch (req.method) {
    case 'POST':
      req.body._modified = metadata;
      req.body._created = metadata;
      collection.insertOne(req.body)
        .then((dbresp: any) => {
          res.send(dbresp.ops[0]);
        })
        .catch((err: any) => {
          validateShema(client, req, res, err);
        });
      break;

    case 'GET':
      doc = await collection.find({}).limit(1000).toArray();
      console.log(doc);
      res.send(doc);
      break;

    default:
      res.status(400);
      res.send({ message: `${req.method} not available (Without ID in URL)` });
  }
});

// Handle errors
srv.use(errorHandler);

// start the express server
srv.listen(port, () => {
  console.log(`server started at http://localhost:${port}`);
});
