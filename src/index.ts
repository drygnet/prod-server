import { Request, Response } from 'express';
import express from 'express';
import jwt from 'express-jwt';
import multer from 'multer';
import GridFsStorage from 'multer-gridfs-storage';
import IAppLocals from './models/IAppLocals';
import config from './server/db';
import { initDB } from './server/initDB';
import {
  addMetadata,
  appIndex,
  errorHandler,
  handleFunction,
  resolveApp,
  resolveCollection,
  resolveDb,
  setClient
} from './server/middleware';
import { MongoHelper } from './server/mongo.helper';
import { publicKey } from './server/public.key';
import validateShema from './server/validate';

MongoHelper.connect(config.DBServer).then((res) => {
  const client = res;
  setClient(client);
  initDB(client);
});

const srv = express();
const port = 4000;

srv.use(express.json());
srv.use(jwt({ secret: publicKey, resultProperty: 'locals.user' }));
srv.use(addMetadata);
srv.use('/appIndex', appIndex);
srv.use('/:appName/*', resolveApp);
srv.use('/:appName/files', resolveDb);
srv.use('/:appName/functions/:functionName', [handleFunction]);
srv.use('/:appName/db/:collection/:id*?', [resolveDb, resolveCollection]);

srv.get('/:appName/info/:collection', resolveDb, async (req, res) => {
  const { db } = (res.locals as IAppLocals);
  const collinfo: any = await db.listCollections({ name: req.params.collection }).next();
  const info = collinfo.options;
  res.send(info);

});

srv.post('/:appName/files', (req: Request, res: Response) => {
  const storage = new GridFsStorage({
    db: res.locals.db,
    file: (request, file) => {
      return {
        bucketName: 'storage',
        filename: file.originalname,
      };
    }
  });

  storage.on('connection', (db) => {
    const upload = multer({
      storage
    }).single('file');
    upload(req, res, (err: any) => {
      if (err) {
        return res.send({ title: 'Uploaded Error', message: 'File could not be uploaded', error: err });
      }
      res.send({ title: 'Uploaded', message: `File has been uploaded!`, id: req.file.id });
    });
  });
});

// Add item to array in document (:id)
srv.post('/:appName/db/:collection/:id/:array', (req: Request, res: Response) => {
  const { collection, client, id, metadata } = (res.locals as IAppLocals);
  const arrayName = req.params.array;
  collection.findOneAndUpdate(
    { _id: id },
    {
      $push: { [arrayName]: req.body },
      $set: { _modified: metadata }
    },
    { returnOriginal: false })
    .then((document: any) => {
      res.send(document.value);
    })
    .catch((error: any) => {
      validateShema(client, req, res, error);
    });
});

srv.use('/:appName/db/:collection/:id', async (req: Request, res: Response) => {
  const { client, id, collection, metadata } = (res.locals as IAppLocals);
  let doc: any;
  if (req.body) {
    // id and metadata generated by server or database, user should not post
    delete req.body._id;
    delete req.body._modified;
    delete req.body._created;
  }
  switch (req.method) {

    case 'GET':
      doc = await collection.findOne({ _id: id });
      res.send(doc);
      break;

    case 'PUT':
      req.body._modified = metadata;
      collection.findOneAndUpdate({ _id: id }, { $set: req.body }, { returnOriginal: false })
        .then((document: any) => {
          res.send(document.value);
        })
        .catch((error: any) => {
          // not true, but skips one validation error
          req.body._created = metadata;
          validateShema(client, req, res, error);
        });
      break;

    case 'DELETE':
      collection.deleteOne({ _id: id })
        .then((result: any) => {
          res.send(result);
        })
        .catch((error: any) => {
          res.status(400);
          res.send(error);
        });
      break;

    default:
      res.status(400)
      res.send({ message: `${req.method} not available` });
  }

});

srv.use('/:appName/db/:collection/', async (req: Request, res: Response) => {
  const { client, id, collection, metadata } = (res.locals as IAppLocals);
  let doc: any;
  if (req.body) {
    // id and metadata generated by server or database, user should not post
    delete req.body._id;
    delete req.body._modified;
    delete req.body._created;
  }
  switch (req.method) {
    case 'POST':
      req.body._modified = metadata;
      req.body._created = metadata;
      collection.insertOne(req.body)
        .then((dbresp: any) => {
          res.send(dbresp.ops[0]);
        })
        .catch((err: any) => {
          validateShema(client, req, res, err);
        });
      break;

    case 'GET':
      doc = await collection.find({}).limit(1000).toArray();
      console.log(doc)
      res.send(doc);
      break;

    default:
      res.status(400)
      res.send({ message: `${req.method} not available` });
  }
});




srv.use(errorHandler);

// start the express server
srv.listen(port, () => {
  console.log(`server started at http://localhost:${port}`);
});
