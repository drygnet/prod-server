import bodyParser from 'body-parser';
import { Request, Response } from 'express';
import express from 'express';
import jwt from 'express-jwt';
import { Collection, MongoClient } from 'mongodb';
import multer from 'multer';
import GridFsStorage from 'multer-gridfs-storage';
import config from './server/db';
import { initDB } from './server/initDB';
import {
  addMetadata,
  appIndex,
  errorHandler,
  handleFunction,
  resolveApp,
  resolveCollection,
  resolveDb,
  setClient
} from './server/middleware';
import { MongoHelper } from './server/mongo.helper';
import { publicKey } from './server/public.key';
import validateShema from './server/validate';

MongoHelper.connect(config.DBServer).then((res) => {
  const client = res;
  setClient(client);
  initDB(client);
});

const jsonParser = bodyParser.json();
const srv = express();
const port = 4000;

srv.use(jsonParser);
srv.use(jwt({ secret: publicKey, resultProperty: 'locals.user' }));
srv.use(addMetadata);
srv.use('/appIndex', appIndex);
srv.use('/:appName/*', resolveApp);
srv.use('/:appName/files', resolveDb);
srv.use('/:appName/functions/:functionName', [handleFunction]);
srv.use('/:appName/db/:collection/:id*?', [resolveDb, resolveCollection]);

srv.get('/:appName/info/:collection', resolveDb, async (req, res) => {
  const db = res.locals.db;
  const collinfo: any = await db.listCollections({ name: req.params.collection }).next();
  const info = collinfo.options;
  res.send(info);

});

srv.post('/:appName/files', (req: Request, res: Response) => {
  const storage = new GridFsStorage({
    db: res.locals.db,
    file: (request, file) => {
      return {
        bucketName: 'storage',
        filename: file.originalname,
      };
    }
  });

  storage.on('connection', (db) => {
    const upload = multer({
      storage
    }).single('file');
    upload(req, res, (err: any) => {
      if (err) {
        return res.send({ title: 'Uploaded Error', message: 'File could not be uploaded', error: err });
      }
      res.send({ title: 'Uploaded', message: `File has been uploaded!`, id: req.file.id });
    });
  });
});

// Add item to array in document (:id)
srv.post('/:appName/db/:collection/:id/:array', (req: Request, res: Response) => {
  const { collection, client, id, metadata } = res.locals;
  const arrayName = req.params.array;
  collection.findOneAndUpdate(
    { _id: id },
    {
      $push: { [arrayName]: req.body },
      $set: { _modified: metadata }
    },
    { returnOriginal: false })
    .then((document: any) => {
      res.send(document.value);
    })
    .catch((error: any) => {
      validateShema(client, req, res, error);
    });
});

// CRUD functions, see switch-black
srv.use('/:appName/db/:collection/:id?', async (req: Request, res: Response) => {
  const id = res.locals.id; // do not take id from req.params
  const client: MongoClient = res.locals.client;
  const collection: Collection = res.locals.collection;

  let doc: any;
  if (req.body) {
    // id and metadata generated by server or database, user should not post
    delete req.body._id;
    delete req.body._modified;
    delete req.body._created;
  }
  switch (req.method) {
    case 'POST':
      if (req.params.id) {
        res.status(400);
        res.send({ error: 'do not POST to endpoint with /:id (POST creates a new document)' });
      } else {
        req.body._modified = res.locals.metadata;
        req.body._created = res.locals.metadata;
        collection.insertOne(req.body)
          .then((dbresp: any) => {
            res.send(dbresp.ops[0]);
          })
          .catch((err: any) => {
            validateShema(client, req, res, err);
          });
      }
      break;

    case 'GET':
      if (req.params.id) {
        doc = await collection.findOne({ _id: id });
        res.send(doc);
      } else {
        doc = await collection.find({ limit: 1000 }).toArray();
        res.send(doc);
      }

      break;

    case 'PUT':
      req.body._modified = res.locals.metadata;
      console.log('META', req.body);
      collection.findOneAndUpdate({ _id: id }, { $set: req.body }, { returnOriginal: false })
        .then((document: any) => {
          res.send(document.value);
        })
        .catch((error: any) => {
          // not true, but skips one validation error
          req.body._created = res.locals.metadata;
          validateShema(client, req, res, error);
        });
      break;

    case 'DELETE':
      collection.deleteOne({ _id: id })
        .then((result: any) => {
          res.send(result);
        })
        .catch((error: any) => {
          res.status(400);
          res.send(error);
        });
      break;

    default:
      doc = await collection.findOne({ _id: id });
      res.send(doc);
  }

});

srv.use(errorHandler);

// start the express server
srv.listen(port, () => {
  console.log(`server started at http://localhost:${port}`);
});
